1. 通道的基础知识
通道的主要目的是并发安全地传递数据，而不是存储数据
通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。
不要通过共享内存来通信，而应该通过通信来共享内存
	ch1 := make(chan int, 3)
	ch1 <- 1
	fmt.Println("first ele", <-ch1)
2. 对通道的发送和接收操作都有哪些基本的特性？
对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
    在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。
        直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。
    元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。
    元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，
        第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。
发送操作和接收操作中对元素值的处理都是不可分割的。
    它们处理元素值时都是一气呵成的，绝不会被打断。
发送操作在完全完成之前会被阻塞。接收操作也是如此。
    发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤
    接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤
    在对应的步骤完全完成之前，发起操作的那句代码会一直阻塞在那里。
        也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。
        更细致地说，在通道完成操作之后，运行时系统会通知这句代码所在的 goroutine，以使它去争取继续运行代码的机会。
    阻塞代码其实就是为了实现操作的互斥和元素值的完整。
3. 发送操作和接收操作在什么时候可能被长时间的阻塞
缓冲通道 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。
    这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。
    当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。
非缓冲通道 无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。
    由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递
只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil, 
    它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。
4. 发送操作和接收操作在什么时候会引发 panic
对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。
    但是通道一旦关闭，再对它进行发送操作，就会引发 panic。
关闭一个已经关闭了的通道，也会引发 panic。
    注意，接收操作是可以感知到通道的关闭的，并能够安全退出
千万不要让接收方关闭通道，而应当让发送方做这件事
5. 元素值在经过通道传递时会被复制，那么这个复制是浅表复制还是深层复制呢
go语言只有两种类型，引用类型和值类型，在复制的时候无论是哪种类型都是值复制，也就是所谓的浅复制
深复制：无论是什么类型都会完整的拷贝一份
6. 单向通道有什么应用价值
单向通道最主要的用途就是约束其他代码的行为。
 Go 语言会自动地把双向通道转换为函数所需的单向通道。
type Notifier interface {
	SendInt(chan<- int)
}
单向通道 只能发不能收，或者只能收不能发的通道。一个通道是双向的，还是单向的是由它的类型字面量体现的。
`chan<-：表示“发送到管道中去”，所以是一个发送通道 <-chan：表示“接收从管道中传来的数据”，所以是一个接收通道`
var uselessChan = make(chan<- int, 1)
func getIntChan() <-chan int {}
7. select语句与通道怎样联用，应该注意些什么
select语句包含的候选分支中的case表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。
仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支
	initChan := make(chan int, 2)
	// initChan <- 5
	time.AfterFunc(time.Second, func() {
		close(initChan)
	})
	select {
	case ele, ok := <-initChan:
		if !ok {
			fmt.Println("close select channel")
			break
		}
		fmt.Println("receive channel ", ele)

	}
如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行
select语句的每次执行，包括case表达式求值和分支选择，都是独立的