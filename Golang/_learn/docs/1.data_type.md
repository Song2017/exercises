1. 怎样估算切片容量的增长
一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。
但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。
在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。
2. 切片的底层数组什么时候会被替换
一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片
在无需扩容时，append函数返回的是指向原底层数组的原切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片
3. 可以把自己生成的Element类型值传给链表吗
不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的Element值并不在链表中
为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏
4. 为什么链表可以做到开箱即用
List和Element都是结构体类型。
结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。
值中的字段也都会被分别赋予各自类型的零值。
“延迟初始化”机制。所谓的延迟初始化，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。
延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。但频繁地调用也会降低性能
5. Ring与List的区别在哪儿
container/ring包中的Ring类型实现的是一个循环链表，也就是我们俗称的环。
其实List在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。
Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。
一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表了一个完整的链表。这是表示维度上的不同。
在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做（也没有必要这样做）。
Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。

6. 为什么字典的键类型会受到约束
Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，
在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。
映射过程的第一步就是：把键值转换为哈希值
7. 字典的键类型不能是哪些类型
Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。
Go 语言规范规定，在键类型的值之间必须可以施加操作符==和!=。换句话说，键类型的值必须要支持判等操作
键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）
每个哈希桶都会把自己包含的所有键的哈希值存起来。Go 语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的，
因为不同值的哈希值是可能相同的。这有个术语，叫做“哈希碰撞”， 所以再用键值本身去对比一次， 
8. 应该优先考虑哪些类型作为字典的键类型
优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。
求哈希和判等操作的速度越快，对应的类型就越适合作为键类型
高级类型。对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度
9. 在值为nil的字典上执行读操作会成功吗，那写操作呢
除了添加键 - 元素对，我们在一个值为nil的字典上做任何操作都不会引起错误
当我们试图在一个值为nil的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。
10. 字典类型的值是并发安全的吗
非原子操作需要加锁， map并发读写需要加锁，map操作不是并发安全的，判断一个操作是否是原子的可以使用 go run race 命令做数据的竞争检测