Don’t communicate by sharing memory; share memory by communicating.
1. 进程与线程
进程 一个进程其实就是某个程序运行时的一个产物
线程 总是在进程之内的，它可以被视为进程中运行着的控制流（或者说代码执行的流程）
    进程的第一个线程都会随着该进程的启动而被创建，它们可以被称为其所属进程的主线程
    如果一个进程中包含了多个线程，那么其中的代码就可以被并发地执行。
        除了进程的第一个线程之外，其他的线程都是由进程中已存在的线程创建出来的
    主线程之外的其他线程都只能由代码显式地创建和销毁
    在 Go 程序当中，Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。
        这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程
    用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。
        用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理
    Go 语言不但有着独特的并发编程模型，以及用户级线程 goroutine，
        还拥有强大的用于调度 goroutine、对接系统级线程的调度器。
2. Go 语言运行时系统
对接系统级线程的调度器 负责统筹调配 Go 并发编程模型中的三个主要元素，
    即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）
    M 指代的就是系统级线程。而 P 指的是一种可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介
从宏观上说，G 和 M 由于 P 的存在可以呈现出多对多的关系。
    当一个正在与某个 M 对接并运行着的 G，需要因某个事件（比如等待 I/O 或锁的解除）而暂停运行的时候，
    调度器总会及时地发现，并把这个 G 与那个 M 分离开，以释放计算资源供那些等待运行的 G 使用。
G 需要恢复运行的时候，调度器又会尽快地为它寻找空闲的计算资源（包括 M）并安排运行。
    另外，当 M 不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个 M 已无用时，
    调度器又会负责把它及时地销毁掉。
3. 什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同
不会有任何内容被打印出来或是打印出乱序, 可重复的的0到10
主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作
    主 goroutine 的go函数就是那个作为程序入口的main函数
go函数真正被执行的时间，总会与其所属的go语句被执行的时间不同。
当程序执行到一条go语句的时候，Go 语言的运行时系统，会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine），
    它只有在找不到空闲 G 的情况下才会去创建一个新的 G。
拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个go函数（或者说该函数中的那些代码），
    然后再把这个 G 追加到某个存放可运行的 G 的队列中
这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。
    虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。
go函数的执行时间总是会明显滞后于它所属的go语句的执行时间
只要go语句本身执行完毕，Go 程序完全不会等待go函数的执行，它会立刻去执行后边的语句。这就是所谓的异步并发地执行。
**一旦主 goroutine 中的代码（也就是main函数中的那些代码）执行完毕，当前的 Go 程序就会结束运行**
**Go 语言并不会去保证这些 goroutine 会以怎样的顺序运行**
4. 怎样才能让主 goroutine 等待其他 goroutine
time.Sleep
通道 长度应该与我们手动启用的 goroutine 的数量一致 
    在每个手动启用的 goroutine 即将运行完毕的时候，我们都要向该通道发送一个值 struct{}{}
    在main函数的最后从通道接收元素值，接收的次数也应该与手动启用的 goroutine 的数量保持一致
sync.WaitGroup
5. 怎样让我们启用的多个 goroutine 按照既定的顺序运行
让count变量成为一个信号，它的值总是下一个可以调用打印函数的go函数的序号
print 增加入参， 接受i值，保证每个 goroutine 都可以拿到一个唯一的整数
    go语句被执行时，我们传给go函数的参数i会先被求值，如此就得到了当次迭代的序号。
    之后，无论go函数会在什么时候执行，这个参数值都不会变。go函数中调用的一定会是那个当次迭代的序号
trigger 获取一个名叫count的变量的值，并判断该值是否与参数i的值相同。
    如果相同，那么就立即调用fn代表的函数，然后把count变量的值加1，最后显式地退出当前的循环。
    否则，我们就先让当前的 goroutine“睡眠”一个纳秒再进入下一个迭代
    操作变量count的时候使用的都是原子操作。
        这是由于trigger函数会被多个 goroutine 并发地调用，所以它用到的非本地变量count，就被多个用户级线程共用了
主 goroutine 最后一个运行完毕， goroutine 都运行完毕之后，count的值一定会是10
func orderRoutine() {
	count := uint32(0) //信号量
	trigger := func(n uint32, fn func()) {
		for {
			if nc := atomic.LoadUint32(&count); n == nc {
				fn()
				atomic.AddUint32(&count, 1) //信号的值总是下一个可以调用打印函数的go函数的序号
				break
			}
			time.Sleep(time.Nanosecond) //进入下一个迭代
		}
	}
	print := func(ii int) {
		fn := func() {
			fmt.Println(ii)
		}
		trigger(uint32(ii), fn) // 安全进行并发打印
	}
	for i := 0; i < 10; i++ {
		go print(i)
	}

	trigger(uint32(10), func() {}) // 确保count达到10后推出
}
6. 同步工具从重到轻
通道 => 读写锁 => 互斥锁 => 原子操作
7. runtime包中提供了哪些与模型三要素 G、P 和 M 相关的函数
