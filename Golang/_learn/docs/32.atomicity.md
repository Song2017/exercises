```
1. 原子操作（atomic operation）    
通过对互斥锁的合理使用，我们可以使一个 goroutine 在执行临界区中的代码时，不被其他的 goroutine 打扰。
    不过，虽然不会被打扰，但是它仍然可能会被中断（interruption）
真正能够保证原子性执行的只有原子操作（atomic operation）。
    原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效。
    即使在拥有多 CPU 核心，或者多 CPU 的计算机系统中，原子操作的保证也是不可撼动的
因为原子操作不能被中断，所以它需要足够简单，并且要求快速
    操作系统层面只对针对二进制位或整数的原子操作提供了支持
Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。
    这些函数都存在于标准库代码包sync/atomic中
2. sync/atomic包中提供了几种原子操作？    
sync/atomic包中的函数可以做的原子操作有：
    加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。
3. 可操作的数据类型又有哪些    
数据类型有：int32、int64、uint32、uint64、uintptr，以及unsafe包中的Pointer。
    不过，针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数。
此外，sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值
4. atomic.AddInt32函数的第一个参数的类型为什么不是int32而是*int32呢    
因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，
    像这种基本类型的值一旦被传入函数，就已经与函数外的那个值毫无关系了。
    所以，传入值本身没有任何意义。unsafe.Pointer类型虽然是指针类型，
    但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针
5. 用于原子加法操作的函数可以做原子减法吗？比如，atomic.AddInt32函数可以用于减小那个被操作的整数值吗？     
当然是可以的。atomic.AddInt32函数的第二个参数代表差量，它的类型是int32，是有符号的。
    如果我们想做原子减法，那么把这个差量设置为负整数就可以了
atomic.AddUint32:  ^uint32(-N-1)
6. 比较并交换操作与交换操作相比有什么不同？优势在哪里？    
比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。
所谓的交换指的是，把新值赋给变量，并返回变量的旧值。
在进行 CAS 操作的时候，函数会先判断被操作变量的当前值，是否与我们预期的旧值相等。
    如果相等，它就把新值赋给该变量，并返回true以表明交换操作已进行；否则就忽略交换操作，并返回false。
7. 自旋锁（spinlock）与互斥锁的区别？
for语句联用atomic.CompareAndSwapInt32就可以实现一种简易的自旋锁（spinlock）
for {
 if atomic.CompareAndSwapInt32(&num2, 10, 0) {
  fmt.Println("The second number has gone to zero.")
  break
 }
 time.Sleep(time.Millisecond * 500)
}
在for语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出for循环。
    这就相当于，只要条件未被满足，当前的流程就会被一直“阻塞”在这里。这在效果上与互斥锁有些类似。
它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他的 goroutine 频繁地改变。
而for语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。
8. 假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原子操作吗？
很有必要。可以对照一下读写锁。
    为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有被修改完的值
    如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。
9. 原子操作函数和互斥锁的使用对比
只涉及并发地读写单一的整数类型值，或者多个互不相关的整数类型值，那就不要再考虑互斥锁了
这主要是因为原子操作函数的执行速度要比互斥锁快得多
而且，它们使用起来更加简单，不会涉及临界区的选择，以及死锁等问题。
当然了，在使用 CAS 操作的时候，我们还是要多加注意的，因为它可以被用来模仿锁，并有可能“阻塞”流程
10. 怎样用好sync/atomic.Value
atomic.Value类型是开箱即用的，我们声明一个该类型的变量（以下简称原子变量）之后就可以直接使用了。
这个类型使用起来很简单，它只有两个指针方法：Store和Load。不过，虽然简单，但还是有一些值得注意的地方的。
    存储值后就不应该再被复制， atomic.Value类型属于结构体类型，而结构体类型属于值类型。
        所以，复制该类型的值会产生一个完全分离的新值
    不能用原子值存储nil， 如果有一个接口类型的变量，它的动态值是nil，
        但动态类型却不是nil，那么它的值就不等于nil
    原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值
        原子值内部是依据被存储值的实际类型来做判断的。所以，即使是实现了同一个接口的不同类型，
        它们的值也不能被先后存储到同一个原子值中
type atomicValue struct {
	v atomic.Value
	t reflect.Type
}
```