1. pointer
对于基本类型Dog来说，*Dog就是它的指针类型。
	而对于一个Dog类型，值不为nil的变量dog，取址表达式&dog的结果就是该变量的值（也就是基本值）的指针值
如果一个方法的接收者是*Dog类型的，那么该方法就是基本类型Dog的指针方法
传统意义上说，指针是一个指向某个确切的内存地址的值
    uintptr, 最贴近pointer，实际上是一个数值类型
    unsafe包中有一个类型叫做Pointer，unsafe.Pointer是像*Dog类型的值这样的指针值和uintptr值之间的桥梁
2. 你能列举出 Go 语言中的哪些值是不可寻址的吗
不可变的, 常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是不可变的。
    基本类型值的字面量也是一样，其实它们本就可以被视为常量，只不过没有任何标识符可以代表它们罢了。
    字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的
    常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
临时结果, 对值字面量施加的表达式的求值结果都看做是临时结果
    对切片字面量的索引结果值是可寻址的。因为不论怎样，每个切片值都会持有一个底层数组
不安全的, “不安全的”操作很可能会破坏程序的一致性，引发不可预知的错误，从而严重影响程序的功能和稳定性
    map的索引表达式的值是不可寻址的，因为其底层位置可能会发生改变，因此不让寻址
如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值
常量的值。
基本类型值的字面量。
算术操作的结果值。
对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。
对字符串变量的索引表达式和切片表达式的结果值。
对字典变量的索引表达式的结果值。
函数字面量和方法字面量，以及对它们的调用表达式的结果值。
结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。
类型转换表达式的结果值。
类型断言表达式的结果值。
接收表达式的结果值。
3. 不可寻址的值在使用上有哪些限制
首当其冲的当然是无法使用取址操作符&获取它们的指针
	// 由于New函数的调用结果值是不可寻址的，所以无法对它进行取址操作
	// New("nico2").SetName("nico2 name") //cannot call pointer method SetName on Cat
	cat2 := New("nico2")
	cat2.SetName("nico2 name")
++或--的左边添加一个表达式，就可以组成一个自增语句或自减语句，
    但是，它还明确了一个很重要的限制，那就是这个表达式的结果值必须是可寻址的
4. 怎样通过unsafe.Pointer操纵可寻址的值？
unsafe.Pointer是像*Dog类型的值这样的指针值和uintptr值之间的桥梁
	// unsafe.Pointer是像*Dog类型的值这样的指针值和uintptr值之间的桥梁
	cat3 := Cat{name: "cat3"}
	catP := &cat3
	catPtr := uintptr(unsafe.Pointer(catP))
	// catPtr2 := uintptr(catP)
	fmt.Println(cat3, catP, catPtr)
	namePtr := catPtr + unsafe.Offsetof(catP.name)
	nameP := (*string)(unsafe.Pointer(namePtr))
	fmt.Println(namePtr, *nameP)
5. 引用类型的值的指针值是有意义的吗？
slice中引用

