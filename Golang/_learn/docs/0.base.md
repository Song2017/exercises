```
- 程序实体
Go 语言中的程序实体包括变量、常量、函数、结构体和接口
- 问题：声明变量有几种方式？
var name string。这里利用了 Go 语言自身的类型推断
name := "123", 短变量声明的用法
- Go 语言的类型推断可以带来哪些好处？
Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率
- 变量的重声明是什么意思
var err error
n, err := io.WriteString(os.Stdout, "Hello, everyone!\n")
它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。
- 如果一个变量与其外层代码块中的变量重名会出现什么状况
对于不同的代码块来说，变量重名是允许的
可重名变量指的是在多个代码块之间由相同的标识符代表的变量。
- 怎样判断一个变量的类型
“类型断言”表达式, 类型断言表达式的语法形式是x.(T)。
其中的x代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的
ss := "test"
value, ok := interface{}(ss).(string)
- 你认为类型转换规则中有哪些值得注意的地方
对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的
var srcInt = int16(-255)
dstInt := int8(srcInt) // 1
string类型与各种切片类型之间的互转
- 什么是别名类型？什么是潜在类型？
type MyString = string // 别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的
type MyString2 string // 注意，这里没有等号。string可以被称为MyString2的潜在类型。潜在类型的含义是，某个类型在本质上是哪个类型
- GPM 模型
P 是 processor 的缩写，每个 processor 都是一个可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接并得到真正运行的中介。
    正是由于 P 的存在，G 和 M 才可以呈现出多对多的关系，并能够及时、灵活地进行组合和分离。
这里的 G 就是 goroutine 的缩写，可以被理解为 Go 语言自己实现的用户级线程。
M 即为 machine 的缩写，代表着系统级线程，或者说操作系统内核级别的线程
Go 语言并发编程模型中的 P，正是 goroutine 的数量能够数十万计的关键所在。
    P 的数量意味着 Go 程序背后的运行时系统中，会有多少个用于承载可运行的 G 的队列存在。
    每一个队列都相当于一条流水线，它会源源不断地把可运行的 G 输送给空闲的 M，并使这两者对接。
    一旦对接完成，被对接的 G 就真正地运行在操作系统的内核级线程之上了。每条流水线之间虽然会有联系，但都是独立运作的。
最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数
```