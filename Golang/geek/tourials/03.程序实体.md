## Go 语言中的程序实体
包括变量、常量、函数、结构体和接口。 
1. Go 语言是静态类型的编程语言，在编译时拒绝ill behaved程序
在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。
这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响
2. 是强类型的编程语言, 声明变量或常量的时候，都需要指定它们的类型，
或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型
3. 在 Go 语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。
常量的合法类型不多，只能是那些 Go 语言预定义的基本类型

### 声明变量有几种方式
1. var name string
var name string // [1]  
flag.StringVar(&name, "name", "everyone", "The greeting object.") // [2]
2. flag.String
var name = flag.String("name", "everyone", "The greeting object.")
变量name代表的是一个指向字符串值的指针, 可以通过操作符*把这个指针指向的字符串值取出来
fmt.Printf("Hello, %v!\n", *name)
3. 短变量声明
name := flag.String("name", "everyone", "The greeting object.")
-  Go 语言中的类型推断，以及它在代码中的基本体现，声明中并没有显式指定name的类型。
    类型推断是一种编程语言在编译期自动解释表达式类型的能力
- 短变量声明的用法
短变量声明，实际上就是 Go 语言的类型推断再加上一点点语法糖, 只能在函数体内部使用短变量声明
#### Go 语言的类型推断可以带来哪些好处
真正的好处，往往会体现在我们写代码之后的那些事情上，比如代码重构. 
我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构
可以随意改变被调用函数的内部实现，及其返回结果的类型，而不用修改调用函数的代码块的任何代码
#### 变量的重声明是什么意思
通过使用短变量声明，我们可以对同一个代码块中的变量进行重声明
1. 变量重声明其实算是一个语法糖（或者叫便利措施）。
它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量
var err error
n, err := io.WriteString(os.Stdout, "Hello, everyone!\n")

### 作用域
程序实体的访问权限有三种：包级私有的、模块级私有的和公开的. 
Go 语言在语言层面，依据代码块对程序实体作用域进行的定义
包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块
- 在 Go 语言中，代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。
- Go 语言本身以及我们编写的代码共同形成了一个非常大的代码块，也叫全域代码块。
这主要体现在，只要是公开的全局变量，都可以被任何代码所使用。
- 相对小一些的代码块是代码包，一个代码包可以包含许多子代码包，所以这样的代码块也可以很大
代码块的划分，也间接地决定了程序实体的作用域
**一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制**
#### 一个变量与其外层代码块中的变量重名会出现什么状况
1. 代码引用变量的时候总会最优先查找当前代码块中的那个变量。
注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。
2. 如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，
从直接包含当前代码块的那个代码块开始，一层一层地查找。
3. 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了
4. 但有个特殊情况，如果我们把代码包导入语句写成import."XXX"的形式（注意中间的那个“.”），
那么就会让这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体
导入的代码包中的变量与当前代码包中的变量重名后, 会报redeclare错误
#### 不同代码块中的可重名变量与变量重声明中的变量区别到底在哪儿
1. 变量重声明中的变量一定是在某一个代码块内的。
注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。
而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个。
而可重名变量中涉及的变量肯定是有多个的。
3. 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。
而可重名变量之间不存在类似的限制，它们的类型可以是任意的。
4. 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。
但是这种现象绝对不会在变量重声明的场景下出现

### 怎样判断一个变量的类型
类型断言表达式: `interface{}(x).(T)`
1. 在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型
任何类型的值都可以很方便地被转换成空接口的值
2. 一对不包裹任何东西的花括号，除了可以代表空的代码块之外，
还可以用于表示**不包含任何内容的数据结构（或者说数据类型）**
3. T: 类型字面量，就是用来表示数据类型本身的若干个字符
`value, ok := interface{}(container).([]string)`
ok也可以没有，可以只被赋给一个变量, 但是这样的话，当判断为否时就会引发异常
#### 类型转换规则中有哪些值得注意的地方
类型转换表达式语法形式是T(x)
x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}{}），还可以是一个表达式
1. 整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的
整数在 Go 语言以及计算机中都是以补码的形式存储的。这主要是为了简化计算机对整数的运算过程。
补码其实就是原码各位求反再加 1
2. 直接把一个整数值转换为一个string类型的值是可行的，
但被转换的整数值应该可以代表一个有效的 Unicode 代码点，
否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）
3. string类型与各种切片类型之间的互转的
一个值在从string类型向[]byte类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节
string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符
string([]rune{'\u4F60', '\u597D'}) // 你好
#### 什么是别名类型？什么是潜在类型
1. 别名类型
`type MyString = string`
MyString是string类型的别名类型。别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的
源类型与别名类型是一对概念，是两个对立的称呼。别名类型主要是为了代码重构而存在的
Go 语言内建的基本类型中就存在两个别名类型。byte是uint8的别名类型，而rune是int32的别名类型
2. 类型再定义
`type MyString2 string`
3. 潜在类型
某个类型在本质上是哪个类型, string可以被称为MyString2的潜在类型
```
- 潜在类型相同的不同类型的值之间是可以进行类型转换的。
因此，MyString2类型的值与string类型的值可以使用类型转换表达式进行互转
- 但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，
因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string。
- 即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值
```
