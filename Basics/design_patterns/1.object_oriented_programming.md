### what is OOP
1. Object Oriented Programming: 
**面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石**
Object Oriented Programming Language:
**面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言**
主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。
面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言
2. 面向对象分析（OOA）和面向对象设计（OOD）。
面向对象分析英文缩写是 OOA，全称是 Object Oriented Analysis；
面向对象设计的英文缩写是 OOD，全称是 Object Oriented Design。
OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段
面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，
面向对象编程就是将分析和设计的的结果翻译成代码的过程
3. UML（Unified Model Language）
统一建模语言，常用它来画图表达面向对象或设计模式的设计思路
UML 在互联网公司的项目开发中，用处可能并不大。
为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了
### 面向对象的四大特性：封装、抽象、继承、多态
1. 封装（Encapsulation）
也叫作信息隐藏或者数据访问保护。
类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据
实现: 访问权限控制, public, private ..., set/get
意义: 一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性
2. 抽象（Abstraction）
抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的
实现: 接口类（interface 关键字语法）或者抽象类（abstract 关键字语法）这两种语法机制，来实现抽象
意义: 一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；
另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息
3. 继承（Inheritance）
继承是用来表示类之间的 is-a 关系. 继承可以分为两种模式，单继承和多继承。
单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类
意义: 继承最大的一个好处就是代码复用
4. 多态（Polymorphism）
多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现
实现: 
    - 继承加方法重写: 
    语法机制是编程语言要支持父类对象可以引用子类对象, 要支持继承, 要支持子类可以重写（override）父类中的方法
    - 接口类语法:
    - duck-typing 语法: 只有一些动态语言才支持
意义: 多态特性能提高代码的可扩展性和复用性, 是很多设计模式、设计原则、编程技巧的代码实现基础
### 面向对象编程与面向过程编程的区别和联系
1. 什么是面向过程编程？什么是面向过程编程语言？
理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。
相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。
相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。
2. 面向对象编程相比面向过程编程有哪些优势？
面向对象编程相比起面向过程编程的优势主要有三个。
- 对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
- 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
- 从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言符合人类的思维, 面向过程更符合机器。
### 面向对象分析、面向对象设计、面向对象编程
三种违反面向对象编程风格的典型代码设计。
- 滥用 getter、setter 方法在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。
除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。
- Constants 类、Utils 类的设计问题对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，
比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。
除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。
- 基于贫血模型的开发模式关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。
这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。
### 接口和抽象类的区别以及各自的应用场景
1. 抽象类和接口的语法特性抽象类不允许被实例化，只能被继承。
它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。
子类继承抽象类，必须实现抽象类中的所有抽象方法。
- 接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。
2. 抽象类和接口存在的意义抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。
接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，
隔离接口和具体的实现，提高代码的扩展性。
3. 抽象类和接口的应用场景区别什么时候该用抽象类？什么时候该用接口？
实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；
如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。
```
// 抽象类
public abstract class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    this.name = name;
    this.enabled = enabled;
    this.minPermittedLevel = minPermittedLevel;
  }
  
  public void log(Level level, String message) {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    if (!loggable) return;
    doLog(level, message);
  }
  
  protected abstract void doLog(Level level, String message);
}
// 抽象类的子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    super(name, enabled, minPermittedLevel);
    this.fileWriter = new FileWriter(filepath); 
  }
  
  @Override
  public void doLog(Level level, String mesage) {
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
```
### 基于接口而非实现编程的设计思想
Program to an interface, not an implementation.
本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。
1. “基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。
我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。
越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。
2. 我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；
另一方面，与特定实现有关的方法不要定义在接口中。
3. “基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，
还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。
### 多用组合少用继承的设计思想
1. 为什么不推荐使用继承？
继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。
虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。
在这种情况下，我们应该尽量少用，甚至不用继承。
2. 组合相比继承有哪些优势？
继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。
而这三个作用都可以通过组合、接口、委托三个技术手段来达成。
除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。
```

public interface Flyable {
  void fly()；
}
public class FlyAbility implements Flyable {
  @Override
  public void fly() { //... }
}
//省略Tweetable/TweetAbility/EggLayable/EggLayAbility

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  private TweetAbility tweetAbility = new TweetAbility(); //组合
  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
  //... 省略其他属性和方法...
  @Override
  public void tweet() {
    tweetAbility.tweet(); // 委托
  }
  @Override
  public void layEgg() {
    eggLayAbility.layEgg(); // 委托
  }
}
```
3. 如何判断该用组合还是继承？
尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。
在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。
如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。
反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。
### 面向过程的贫血模型和面向对象的充血模型
1. 只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）:
贫血模型将数据与操作分离，破坏了面向对象的封装特性
2. 充血模型（Rich Domain Model）:
数据和对应的业务逻辑被封装到同一个类中
3. 领域驱动设计，即 DDD
DDD is nothing more than OOP applied to business models. DDD其实就是把OOP应用于业务模型
主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互
领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行
DDD第一原则：将数据和操作结合。（贫血模型将数据和操作分离，违反OOP的原则。）
DDD第二原则：界限上下文。这是将“单一指责”应用于我们的领域模型。
4. 基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比
- 主要区别在 Service 层。
在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，
让 Service 类的实现依赖这个 Domain 类。在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，
而是负责一些不适合放在 Domain 类中的功能。
比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。
- Controller 层和 Repository 层的代码基本上相同。
这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。
两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。
所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。
### 实例
#### 面向对象分析
面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。
针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，
做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。
需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。
所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。
需求分析的过程实际上是一个不断迭代优化的过程。
我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，
有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。
#### 面向对象设计
在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。
这个环节的工作可以拆分为下面四个部分。
1. 划分职责进而识别出有哪些类根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，
然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。
2. 定义类及其属性和方法我们识别出需求描述中的动词，作为候选的方法，
再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。
3. 定义类与类之间的交互关系UML 统一建模语言中定义了六种类之间的关系。
它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，
对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。
4. 将类组装起来并提供执行入口我们要将所有的类组装在一起，提供一个执行入口。
这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。