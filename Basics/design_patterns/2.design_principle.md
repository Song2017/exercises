## 设计原则 
设计原则是指导我们代码设计的一些经验总结。
设计原则有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。
所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。
对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。
### SOLID 原则 -SRP 单一职责原则
单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP
1. 如何理解单一职责原则（SRP）？
一个类只负责完成一个职责或者功能。
不要设计大而全的类，要设计粒度小、功能单一的类。
单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。
2. 如何判断类的职责是否足够单一？
不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。
实际上，一些侧面的判断指标更具有指导意义和可执行性，
比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：
- 类中的代码行数、函数或者属性过多；
- 类依赖的其他类过多，或者依赖类的其他类过多；
- 私有方法过多；
- 比较难给类起一个合适的名字；
- 类中大量的方法都是集中操作类中的某几个属性。
- 量化的标准，那就是一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个
3. 类的职责是否设计得越单一越好？
单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。
同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，
以此来实现代码的高内聚、低耦合。
但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。
### SOLID 原则 -OCP 开闭原则
开闭原则的英文全称是 Open Closed Principle，简写为 OCP. 
软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”, 对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性
1. 如何理解“对扩展开放、对修改关闭”？
第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。
第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。
2. 如何做到“对扩展开放、修改关闭”？
我们要时刻具备扩展意识、抽象意识、封装意识。事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。
23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。
最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）
3. 代码实现
将入参封装成类: 通过修改类的属性就可以决定入参的个数, 作用
引入 handler 的概念, 将业务逻辑分散在各个 handler 中
### SOLID 原则 -LSP 里式替换原则
里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP
子类对象（object of subtype/derived class）能够替换程序中父类对象（object of base/parent class）出现的任何地方，
并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏
1. 里式替换原则是用来指导，继承关系中子类该如何设计的一个原则
理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。
父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。
这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
2. 里式替换原则跟多态的区别
虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。
多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。
它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，
子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。
3. 违背了LSP的代码
1 子类违背父类声明要实现的功能
2 子类违背父类对输入、输出、异常的约定
3 子类违背父类注释中所罗列的任何特殊说明
### SOLID 原则 -ISP 接口隔离原则
接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为 ISP
客户端不应该强迫依赖它不需要的接口
1. 如何理解“接口隔离原则”？
理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。
如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。
如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，
    单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，
    那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。
    那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。
2. 接口隔离原则与单一职责原则的区别
单一职责原则针对的是模块、类、接口的设计。
接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。
接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。
    如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
### SOLID 原则 -DIP 依赖倒置原则
依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP
1. 控制反转
实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。
这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。
在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。
2. 依赖注入
依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。
我们不通过 new 的方式在类内部创建依赖类的对象，
而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。
3. 依赖注入框架
我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，
就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。
4. 依赖反转原则
依赖反转原则也叫作依赖倒置原则。
这条原则跟控制反转有点类似，主要用来指导框架层面的设计。
高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。
### DRY 原则、KISS 原则、YAGNI 原则、LOD 法则
KISS原则 
Keep It Short and Simple, 尽量保持简单
不要使用同事可能不懂的技术来实现代码；不要重复造轮子，要善于使用已经有的工具类库；不要过度优化
DRY 原则
Don’t Repeat Yourself, 不要重复自己